/*
  The evt class serves to simplify the transfer and arrangement of data
  throughout or program. All events are required to have a description, a year,
  players involved, eType (event type 1-9).
*/

var Evt= function(year,eType,desc,players){
  this.year=year;
  this.eType=eType;
  this.desc=desc;
  this.players=players;
}

Evt.prototype.getPlayers = function () {
  var ps=[];
  for(var i in this.players){
    ps.push(this.players[i][0]);
  }
  return ps;
}

Evt.prototype.getColors = function () {
  var cs=[];
  for(var i in this.players){
    cs.push(this.players[i][0]);
  }
};

/*
  EventFactory is responsible for loading all events and placinge them into the
  global scope for visualizations to utilize.

  It can generate events in a number of ways, and its generated events will be
  accessible through the .events selector.

  You could feasably have multiple events based on different datasets.
*/

var EventSet= function(){
  this.events=[];// this will contain all Evts generated by this factory.
  this.loaded=false;
}

EventSet.prototype.createEvt=function(evtData){
  var year=evtData.year,
      eType=evtData.eventType,
      desc=evtData.text,
      players=[[evtData.country,evtData.color]];
  this.events.push(new Evt(year,eType,desc,players));
};

/*
  This function is meant to be called with a callback to execute after loading
  the data. This is due to the asynchronous nature of d3.csv().
*/
EventSet.prototype.loadFromCSV=function(csvFile,callback){
  this.events=[];
  var self = this;
  d3.csv(csvFile,function(allData){
    for(i in allData){
      self.createEvt(allData[i]);
    }
    callback();
  });
}

// generates a grid with default styles
var Grid= function(location,styles=null){
  var defaultGridStyle={
    lines:[.25,2,18], // [0]--> most thin, [2]--> most thick
    colors:{
      empty:"#fff",
      hlght:"#",
      hvr:"#",
      evt:"#000",
      yr:"#FAAE3C",
      cent:"#DB882A"
    },
    sz:16 //size of squares-- affects inner square sizes, not lines.
  }
  this.styles= (styles==null) ? defaultGridStyle : styles;
  this.loc=location;// the id of the svg to append to

  /*  the !!outermost!! position of the top right corner--
      stroke is not factored in here. I.E. How much to shift the grid once it0
      has been drawn.
  */
  this.pos=[0,0];
  this.evtSet=null;
}
Grid.prototype.getCenturySize=function(){ //gets inner size of century
  return this.styles.sz*30+this.styles.lines[0]*20+
    this.styles.lines[1]*8 + 2*this.styles.lines[2];
}
Grid.prototype.addEventSet=function(evtSet){
  this.evtSet=evtSet;
}

Grid.prototype.addEvtRep=function(tp,two){
  var x=Math.floor(tp/3)*(this.styles.lines[0]+this.styles.sz);
  var y=(tp%3)*(this.styles.lines[0]+this.styles.sz);
  console.log("("+x+","+y+")");
  var r=two.makeRectangle(x+this.styles.sz/2,y+this.styles.sz/2,this.styles.sz,this.styles.sz)
  r.linewidth=0;
  r.fill=this.styles.colors.empty;
  return r;
}

Grid.prototype.draw= function(two){// draws grid DOES NOT POPULATE IT
  // I add the main grid rectangle (the century block)
  var cSz=this.getCenturySize();
  var cSzOuter=cSz + 2*this.styles.lines[2];
  var century=two.makeRectangle(0,0,cSz,cSz);
  century.translation.set((cSz+this.styles.lines[2])/2,(cSz+this.styles.lines[2])/2);
  century.linewidth= this.styles.lines[2];
  century.stroke=this.styles.colors.cent;
  var allGrid= two.makeGroup(century);
  // Once I have the main bounds, I put in the main lines-- the years, and the subsections.
  // year lines
  var yearLines=two.makeGroup();
  var topLines=two.makeGroup();
  var bleh=1;
  // subsection lines
  var evtLines=two.makeGroup();
  var bleh=1;
  for(var i=1; i<30; i++){
    if(i==15){
      bleh=-1;
    }
    if(i%3!=0){
      var pos= Math.floor(i/3)*this.styles.lines[1]+i*(this.styles.sz)+
        (i-1)*this.styles.lines[0]/2+Math.floor(i/15)*this.styles.lines[2]+
        (bleh*(this.styles.lines[0]/2));

      var line1=two.makeLine(0,pos,cSz-this.styles.lines[2],pos),//  x, y, x1, y1
          line2=two.makeLine(pos,0,pos,cSz-this.styles.lines[2]);

      // define line characteristics
      line1.linewidth=this.styles.lines[0];
      line2.linewidth=this.styles.lines[0];
      line1.stroke=this.styles.colors.evt;
      line2.stroke=this.styles.colors.evt;
      evtLines.add(line1)
      evtLines.add(line2)
    }
  }
  evtLines.addTo(yearLines)
  var bleh=1;
  for(var i=1; i<10; i++){
    // if the line is a century line.
    if(i==5){
      bleh=-1;
      pos=(this.styles.lines[1])*(i-1)+(this.styles.sz*3+this.styles.lines[0]*2)*i+
        this.styles.lines[2]/2;
      //horizontal line1
      var line1=two.makeLine(-1,pos,cSz-this.styles.lines[2]+1,pos),//  x, y, x1, y1
      //vertical line
        line2=two.makeLine(pos,-1,pos,cSz-this.styles.lines[2]+1);
      line1.linewidth=this.styles.lines[2];
      line2.linewidth=this.styles.lines[2];
      line1.stroke=this.styles.colors.cent;
      line2.stroke=this.styles.colors.cent;
      topLines.add(line1);
      topLines.add(line2);
    //if the line is a year line
    }else{
      pos=(this.styles.lines[1])*(i-1)+(this.styles.sz*3+this.styles.lines[0]*2)*i+
        (this.styles.lines[2])*Math.floor(i/5)+(bleh*(this.styles.lines[1]/2));
      //horizontal line
      var line1=two.makeLine(0,pos,cSz-this.styles.lines[2],pos),//  x, y, x1, y1
      //vertical line
        line2=two.makeLine(pos,0,pos,cSz-this.styles.lines[2]);
      line1.linewidth=this.styles.lines[1];
      line2.linewidth=this.styles.lines[1];
      line1.stroke=this.styles.colors.yr;
      line2.stroke=this.styles.colors.yr;
      yearLines.add(line1);
      yearLines.add(line2);
    }
  }
  topLines.addTo(yearLines);
  yearLines.translation.set(this.styles.lines[2],this.styles.lines[2]);
  //yearLines.translation.set(this.styles.lines[2],this.styles.lines[2]);

  // represent all events on the grid.
  var evtReps=two.makeGroup()
  // for each decade
  for(var i=0; i<10; i++){
    // for each year in that decade
    for(var j=0; j<10; j++){
      yr=(i*10)+j+1;
      yearGroup=two.makeGroup();
      // for each event type in that year
      for(var k=0; k<9; k++){
        //  addEvtRep(eType); determines position of and draws a rectangle/rect-tri
        //  combo to represent the event or lack thereof, given the current year
        //  and eType.
        yearGroup.add(this.addEvtRep(k,two));
      }// end event loop
      yrX=(this.styles.lines[1]+this.styles.sz*3+2*this.styles.lines[0])*j+
        (Math.floor(j/5)*(this.styles.lines[2]-this.styles.lines[1]));
        console.log(j,"X OFFSET:",yrX);
      yrY=(this.styles.lines[1]+this.styles.sz*3+2*this.styles.lines[0])*i+
        (Math.floor(i/5)*(this.styles.lines[2]-this.styles.lines[1]));
      yearGroup.translation.set(yrX,yrY);
      console.log(yearGroup.translation);
      yearGroup.addTo(evtReps);
    }// end year loop
    evtReps.translation.set(this.styles.lines[2],this.styles.lines[2]);
  }// end decade loop
  evtReps.addTo(allGrid)
  yearLines.addTo(allGrid)
  /**/
  // update two
  two.update();
  return;
}
