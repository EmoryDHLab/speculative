/*
  The evt class serves to simplify the transfer and arrangement of data
  throughout or program. All events are required to have a description, a year,
  players involved, eType (event type 1-9).
*/

var Evt= function(year,eType,desc,players){
  this.year=year;
  this.eType=eType;
  this.desc=desc;
  this.players=players;
}

Evt.prototype.getPlayers = function () {
  var ps=[];
  for(var i in this.players){
    ps.push(this.players[i][0]);
  }
  return ps;
}

Evt.prototype.getColors = function () {
  var cs=[];
  for(var i in this.players){
    cs.push(this.players[i][0]);
  }
};

/*
  EventFactory is responsible for loading all events and placinge them into the
  global scope for visualizations to utilize.

  It can generate events in a number of ways, and its generated events will be
  accessible through the .events selector.

  You could feasably have multiple events based on different datasets.
*/

var EventSet= function(){
  this.events=[];// this will contain all Evts generated by this factory.
  this.loaded=false;
}

EventSet.prototype.createEvt=function(evtData){
  var year=evtData.year,
      eType=evtData.eventType,
      desc=evtData.text,
      players=[[evtData.country,evtData.color]];
  this.events.push(new Evt(year,eType,desc,players));
};

/*
  This function is meant to be called with a callback to execute after loading
  the data. This is due to the asynchronous nature of d3.csv().
*/
EventSet.prototype.loadFromCSV=function(csvFile,callback){
  this.events=[];
  var self = this;
  d3.csv(csvFile,function(allData){
    for(i in allData){
      self.createEvt(allData[i]);
    }
    callback();
  });
}

// generates a grid with default styles
var Grid= function(location,styles=null){
  var defaultGridStyle={
    lines:[.25,2,18], // [0]--> most thin, [2]--> most thick
    colors:{
      empty:"#fff",
      hlght:"#",
      hvr:"#",
      evt:"#B3B3B3",
      yr:"#FAAE3C",
      cent:"#DB882A"
    },
    sz:16 //size of squares-- affects inner square sizes, not lines.
  }
  this.styles= (styles==null) ? defaultGridStyle : styles;
  this.loc=location;// the id of the svg to append to

  /*  the !!outermost!! position of the top right corner--
      stroke is not factored in here. I.E. How much to shift the grid once it0
      has been drawn.
  */
  this.pos=[0,0];
  this.evtSet=null;
}
Grid.prototype.getCenturySize=function(){
  return this.styles.sz*30+this.styles.lines[0]*60+
    this.styles.lines[1]*8+this.styles.lines[2];
}
Grid.prototype.addEventSet=function(evtSet){
  this.evtSet=evtSet;
}

Grid.prototype.addEvtRep=function(tp,two){
  x=Math.floor(tp/3)*(this.styles.lines[0]+this.styles.sz);
  y=(tp%3)*(this.styles.lines[0]+this.styles.sz);
  console.log("("+x+","+y+")");
  return two.makeRectangle(x,y,this.styles.sz,this.styles.sz);
}

Grid.prototype.draw= function(two){// draws grid DOES NOT POPULATE IT
  // I add the main grid rectangle (the century block)
  var cSz=this.getCenturySize();
  var century=two.makeRectangle(cSz/2,cSz/2,cSz,cSz);
  century.linewidth= this.styles.lines[2];
  century.stroke=this.styles.colors.cent;
  var allGrid= two.makeGroup(century);
  // Once I have the main bounds, I put in the main lines-- the years, and the subsections.
  // year lines
  var yearLines=two.makeGroup();
  var topLines=two.makeGroup();
  for(var i=1; i<10; i++){
    // if the line is a century line.
    if(i==5){
      pos=(this.styles.lines[1])*(i-1)+(this.styles.sz*3)*i+
        this.styles.lines[2]/2;
      //horizontal line
      var line1=two.makeLine(0,pos,cSz-this.styles.lines[2],pos),//  x, y, x1, y1
      //vertical line
        line2=two.makeLine(pos,0,pos,cSz-this.styles.lines[2]);
      line1.linewidth=this.styles.lines[2];
      line2.linewidth=this.styles.lines[2];
      line1.stroke=this.styles.colors.cent;
      line2.stroke=this.styles.colors.cent;
      topLines.add(line1);
      topLines.add(line2);
    //if the line is a year line
    }else{
      pos=(this.styles.lines[1])*(i-1)+(this.styles.sz*3)*i+
        this.styles.lines[2]*(Math.floor(i/5));
      //horizontal line
      var line1=two.makeLine(0,pos,cSz-this.styles.lines[2],pos),//  x, y, x1, y1
      //vertical line
        line2=two.makeLine(pos,0,pos,cSz-this.styles.lines[2]);
      line1.linewidth=this.styles.lines[1];
      line2.linewidth=this.styles.lines[1];
      line1.stroke=this.styles.colors.yr;
      line2.stroke=this.styles.colors.yr;
      yearLines.add(line1);
      yearLines.add(line2);
    }
  }
  topLines.addTo(yearLines);
  yearLines.translation.set((this.styles.lines[2]/2),this.styles.lines[2]/2);
  //
  /* subsection lines
  var evtLines=[];
  for(var i=1; i<30; i++){
    if(i%3!=0){
      horiz=this.x+(this.styles.sz*i);
      vert=this.y+(this.styles.sz*i);
      var line1=two.makeLine(0,1,2,3),//  x, y, x1, y1
        line2=two.makeLine(1,100,1000,0);
      if(i==5){
        line1.linewidth=this.styles.lines[0];
        line2.linewidth=this.styles.lines[0];
      }else{
        line1.linewidth=this.styles.lines[0];
        line2.linewidth=this.styles.lines[0];
      }
      line1.stroke=this.styles.colors.evt;
      line2.stroke=this.styles.colors.evt;
      evtLines.push(line1)
      evtLines.push(line2)
    }
  }
  */
  // represent all events on the grid.
  var evtReps=two.makeGroup()
  // for each decade
  for(var i=0; i<10; i++){
    // for each year in that decade
    for(var j=0; j<10; j++){
      yr=(i*10)+j+1;
      yearGroup=two.makeGroup();
      // for each event type in that year
      for(var k=0; k<9; k++){
        /*
          addEvtRep(eType); determines position of and draws a rectangle/rect-tri
          combo to represent the event or lack thereof, given the current year
          and eType.
        */
        yearGroup.add(this.addEvtRep(k,two));
      }// end event loop
      yrX=(this.styles.lines[1]+this.styles.sz*3)*j+
        (Math.floor(j/5)*this.styles.lines[2]);
      yrY=(this.styles.lines[1]+this.styles.sz*3)*i+
        (Math.floor(i/5)*this.styles.lines[2]);
      yearGroup.translation.set(yrX,yrY);
      yearGroup.addTo(evtReps);
    }// end year loop
    evtReps.translation.set(this.styles.lines[2],this.styles.lines[2]);
  }// end decade loop
  // update two
  two.update();
  return
}
